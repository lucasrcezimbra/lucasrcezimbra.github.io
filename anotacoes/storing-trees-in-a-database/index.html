<!doctype html><html lang=pt><head><title>Storing trees in a database · Lucas Cezimbra
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Lucas Cezimbra"><meta name=description content='
  Q&amp;A
  
    
    Link to heading
  


  ltree - What happens if I query .*foo.* but there are 2 &ldquo;foo"s in two diferent trees in my databases?
  
    
    Link to heading
  


  References
  
    
    Link to heading
  


  Modeling Hierarchical Tree Data in PostgreSQL
  
    
    Link to heading
  


Modeling Hierarchical Tree Data in PostgreSQL
example: hierarchy of countries, states and cities
Approach #1: Static tree schema

example: 3 tables: country, state, city
constraints: fixed tree-depth; ancestors/descendants queries become
more complex proportionally to the depth of the trees;
pros: simple; easy to enforce integrity constraints;
cons: lack of flexibility;
better to model as a actual tree if you want to use tree operations
and traversal queries


Approach #2: Dynamic tree with Recursive Common Table Expression (CTE)

example: 1 table with a parent column
pros: flexibility; arbitrary tree-depth; easy to do traversal queries
cons: medium complexity queries; may not work in another RDBMS


Approach #3: Label tree (ltree) materialized path

example: 1 table with a path column type
ltree
constraints: assumes that there is only one path from the root to any
given node; the application must build the path.
pros: flexible; arbitrary tree-depth; the simplest queries (may not
make diference when using ORMs)
cons: may not work in another RDBMS; needs to every node in the
subtree whenever one ancestor changes




  Do&rsquo;s and Don&rsquo;ts of Storing Large Trees in PostgreSQL
  
    
    Link to heading
  


Do&rsquo;s and Don&rsquo;ts of Storing Large Trees in PostgreSQL


The parent_id column

(Almost) always use; even when using ltree
pros: enforce the tree structure; can be used to rebuild the materialized
path if becomes inconsistent; simple to move subtrees; easy concurrent
updates
cons: the tree needs to be written in a specific order respecting
the relationships; inserting by path is harder
You must have a unique constraint on the column representing the path name

example: if you have two nodes with a name set to be "backup", then you
cannot have a path based on the name, like /system/backup because it
would map to two different nodes.
Option 1: store the full path

example: path column with a unique constraint containing the full
path from the root to the node
cons: need to update the path column on every move operation;


Option 2: store the path component

example: name column with a unique constraint together with the
parent_id






Materialized paths

best use cases: tree rarely changes and you need to do traversal queries;
the source of truth for the tree is external, and you are only reading
and replicating.
avoid: when you have a lot of writes/levels/nodes in the tree; when the
nodes chage position frequently.
pros: simple query;
cons: hard to maintain consistency, you need to update the ltree in the
whole tree everytime you move/rename a node in a transaction; write
performance


'><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:image content="https://cezimbra.me/images/lucas-180x180.jpg"><meta name=twitter:title content="Storing trees in a database"><meta name=twitter:description content='
  Q&amp;A
  
    
    Link to heading
  


  ltree - What happens if I query .*foo.* but there are 2 &ldquo;foo"s in two diferent trees in my databases?
  
    
    Link to heading
  


  References
  
    
    Link to heading
  


  Modeling Hierarchical Tree Data in PostgreSQL
  
    
    Link to heading
  


Modeling Hierarchical Tree Data in PostgreSQL
example: hierarchy of countries, states and cities
Approach #1: Static tree schema

example: 3 tables: country, state, city
constraints: fixed tree-depth; ancestors/descendants queries become
more complex proportionally to the depth of the trees;
pros: simple; easy to enforce integrity constraints;
cons: lack of flexibility;
better to model as a actual tree if you want to use tree operations
and traversal queries


Approach #2: Dynamic tree with Recursive Common Table Expression (CTE)

example: 1 table with a parent column
pros: flexibility; arbitrary tree-depth; easy to do traversal queries
cons: medium complexity queries; may not work in another RDBMS


Approach #3: Label tree (ltree) materialized path

example: 1 table with a path column type
ltree
constraints: assumes that there is only one path from the root to any
given node; the application must build the path.
pros: flexible; arbitrary tree-depth; the simplest queries (may not
make diference when using ORMs)
cons: may not work in another RDBMS; needs to every node in the
subtree whenever one ancestor changes




  Do&rsquo;s and Don&rsquo;ts of Storing Large Trees in PostgreSQL
  
    
    Link to heading
  


Do&rsquo;s and Don&rsquo;ts of Storing Large Trees in PostgreSQL


The parent_id column

(Almost) always use; even when using ltree
pros: enforce the tree structure; can be used to rebuild the materialized
path if becomes inconsistent; simple to move subtrees; easy concurrent
updates
cons: the tree needs to be written in a specific order respecting
the relationships; inserting by path is harder
You must have a unique constraint on the column representing the path name

example: if you have two nodes with a name set to be "backup", then you
cannot have a path based on the name, like /system/backup because it
would map to two different nodes.
Option 1: store the full path

example: path column with a unique constraint containing the full
path from the root to the node
cons: need to update the path column on every move operation;


Option 2: store the path component

example: name column with a unique constraint together with the
parent_id






Materialized paths

best use cases: tree rarely changes and you need to do traversal queries;
the source of truth for the tree is external, and you are only reading
and replicating.
avoid: when you have a lot of writes/levels/nodes in the tree; when the
nodes chage position frequently.
pros: simple query;
cons: hard to maintain consistency, you need to update the ltree in the
whole tree everytime you move/rename a node in a transaction; write
performance


'><meta name=twitter:site content="@lucasrcezimbra"><meta property="og:url" content="https://cezimbra.me/anotacoes/storing-trees-in-a-database/"><meta property="og:site_name" content="Lucas Cezimbra"><meta property="og:title" content="Storing trees in a database"><meta property="og:description" content='Q&amp;A Link to heading ltree - What happens if I query .*foo.* but there are 2 “foo"s in two diferent trees in my databases? Link to heading References Link to heading Modeling Hierarchical Tree Data in PostgreSQL Link to heading Modeling Hierarchical Tree Data in PostgreSQL example: hierarchy of countries, states and cities Approach #1: Static tree schema example: 3 tables: country, state, city constraints: fixed tree-depth; ancestors/descendants queries become more complex proportionally to the depth of the trees; pros: simple; easy to enforce integrity constraints; cons: lack of flexibility; better to model as a actual tree if you want to use tree operations and traversal queries Approach #2: Dynamic tree with Recursive Common Table Expression (CTE) example: 1 table with a parent column pros: flexibility; arbitrary tree-depth; easy to do traversal queries cons: medium complexity queries; may not work in another RDBMS Approach #3: Label tree (ltree) materialized path example: 1 table with a path column type ltree constraints: assumes that there is only one path from the root to any given node; the application must build the path. pros: flexible; arbitrary tree-depth; the simplest queries (may not make diference when using ORMs) cons: may not work in another RDBMS; needs to every node in the subtree whenever one ancestor changes Do’s and Don’ts of Storing Large Trees in PostgreSQL Link to heading Do’s and Don’ts of Storing Large Trees in PostgreSQL The parent_id column (Almost) always use; even when using ltree pros: enforce the tree structure; can be used to rebuild the materialized path if becomes inconsistent; simple to move subtrees; easy concurrent updates cons: the tree needs to be written in a specific order respecting the relationships; inserting by path is harder You must have a unique constraint on the column representing the path name example: if you have two nodes with a name set to be "backup", then you cannot have a path based on the name, like /system/backup because it would map to two different nodes. Option 1: store the full path example: path column with a unique constraint containing the full path from the root to the node cons: need to update the path column on every move operation; Option 2: store the path component example: name column with a unique constraint together with the parent_id Materialized paths best use cases: tree rarely changes and you need to do traversal queries; the source of truth for the tree is external, and you are only reading and replicating. avoid: when you have a lot of writes/levels/nodes in the tree; when the nodes chage position frequently. pros: simple query; cons: hard to maintain consistency, you need to update the ltree in the whole tree everytime you move/rename a node in a transaction; write performance'><meta property="og:locale" content="pt"><meta property="og:type" content="article"><meta property="article:section" content="anotacoes"><meta property="article:published_time" content="2024-10-08T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-08T00:00:00+00:00"><meta property="og:image" content="https://cezimbra.me/images/lucas-180x180.jpg"><link rel=canonical href=https://cezimbra.me/anotacoes/storing-trees-in-a-database/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.aa5ef26fa979d6793724ae2dbd71efa94fd16cb1c5c7db3b6651f21f9892a5fd.css integrity="sha256-ql7yb6l51nk3JK4tvXHvqU/RbLHFx9s7ZlHyH5iSpf0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/contribution.min.cc4187dd6677d15a0c4438b74294dbe3f54269e14a831b267fb6f02a24f90d5d.css integrity="sha256-zEGH3WZ30VoMRDi3QpTb4/VCaeFKgxsmf7bwKiT5DV0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/custom.min.2ef373c2c125094d9302d8a924eba231d053340611b63bcf581460745cef626f.css integrity="sha256-LvNzwsElCU2TAtipJOuiMdBTNAYRtjvPWBRgdFzvYm8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/jquery.dataTables.min.min.8f6eae843117db9532d2c9b910f3b28834d22d85107ce9aba8b5abbeab67400a.css integrity="sha256-j26uhDEX25Uy0sm5EPOyiDTSLYUQfOmrqLWrvqtnQAo=" crossorigin=anonymous media=screen><link rel=stylesheet href=/project.min.cc15fca9f603b853c828be903488d99afe86c71e40721cc4927e27f7453a4a36.css integrity="sha256-zBX8qfYDuFPIKL6QNIjZmv6Gxx5AchzEkn4n90U6SjY=" crossorigin=anonymous media=screen><link rel=stylesheet href=/timeline.min.801628785543d9e7f6deb109e9561a48da7823522c0986a7dd47be117447e62f.css integrity="sha256-gBYoeFVD2ef23rEJ6VYaSNp4I1IsCYan3Ue+EXRH5i8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/vis-timeline-graph2d.min.min.15aad78c7961c518a27d54923d04eea2b750b66ebea8f490d9fe599da0ae8928.css integrity="sha256-FarXjHlhxRiifVSSPQTuordQtm6+qPSQ2f5ZnaCuiSg=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/lucas-32x32.jpg sizes=32x32><link rel=icon type=image/png href=/images/lucas-16x16.jpg sizes=16x16><link rel=apple-touch-icon href=/images/lucas-180x180.jpg><link rel=apple-touch-icon sizes=180x180 href=/images/lucas-180x180.jpg><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body hx-boost=true class="preload-transitions colorscheme-dark"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://cezimbra.me/>Lucas Cezimbra
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/sobre/>Sobre</a></li><li class=navigation-item><a class=navigation-link href=/projetos/>Projetos</a></li><li class=navigation-item><a class=navigation-link href=/anotacoes/indice/>Anotações</a></li><li class=navigation-item><a class=navigation-link href=/palestras/>Palestras</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=https://toolbox.cezimbra.me/>Toolbox ↗</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class=navigation-item><a href=/en/>🇺🇸</a></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://cezimbra.me/anotacoes/storing-trees-in-a-database/>Storing trees in a database</a></h1></header><h2 id=qa>Q&amp;A
<a class=heading-link href=#qa><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=ltree---what-happens-if-i-query-foo-but-there-are-2-foos-in-two-diferent-trees-in-my-databases>ltree - What happens if I query <code>.*foo.*</code> but there are 2 &ldquo;foo"s in two diferent trees in my databases?
<a class=heading-link href=#ltree---what-happens-if-i-query-foo-but-there-are-2-foos-in-two-diferent-trees-in-my-databases><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><h2 id=references>References
<a class=heading-link href=#references><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=modeling-hierarchical-tree-data-in-postgresql>Modeling Hierarchical Tree Data in PostgreSQL
<a class=heading-link href=#modeling-hierarchical-tree-data-in-postgresql><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li><a href=https://leonardqmarcq.com/posts/modeling-hierarchical-tree-data class=external-link target=_blank rel=noopener>Modeling Hierarchical Tree Data in PostgreSQL</a></li><li>example: hierarchy of countries, states and cities</li><li>Approach #1: Static tree schema<ul><li>example: 3 tables: country, state, city</li><li>constraints: fixed tree-depth; ancestors/descendants queries become
more complex proportionally to the depth of the trees;</li><li>pros: simple; easy to enforce integrity constraints;</li><li>cons: lack of flexibility;</li><li>better to model as a actual tree if you want to use tree operations
and traversal queries</li></ul></li><li>Approach #2: Dynamic tree with Recursive Common Table Expression (CTE)<ul><li>example: 1 table with a parent column</li><li>pros: flexibility; arbitrary tree-depth; easy to do traversal queries</li><li>cons: medium complexity queries; may not work in another RDBMS</li></ul></li><li>Approach #3: Label tree (ltree) materialized path<ul><li>example: 1 table with a path column type
<a href=https://www.postgresql.org/docs/9.1/ltree.html class=external-link target=_blank rel=noopener><code>ltree</code></a></li><li>constraints: assumes that there is only one path from the root to any
given node; the application must build the path.</li><li>pros: flexible; arbitrary tree-depth; the simplest queries (may not
make diference when using ORMs)</li><li>cons: may not work in another RDBMS; needs to every node in the
subtree whenever one ancestor changes</li></ul></li></ul><h3 id=dos-and-donts-of-storing-large-trees-in-postgresql>Do&rsquo;s and Don&rsquo;ts of Storing Large Trees in PostgreSQL
<a class=heading-link href=#dos-and-donts-of-storing-large-trees-in-postgresql><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li><a href=https://leonardqmarcq.com/posts/dos-and-donts-of-modeling-hierarchical-trees-in-postgres class=external-link target=_blank rel=noopener>Do&rsquo;s and Don&rsquo;ts of Storing Large Trees in PostgreSQL</a></li></ul><ol><li>The parent_id column<ul><li>(Almost) always use; even when using ltree</li><li>pros: enforce the tree structure; can be used to rebuild the materialized
path if becomes inconsistent; simple to move subtrees; easy concurrent
updates</li><li>cons: the tree needs to be written in a specific order respecting
the relationships; inserting by path is harder</li><li>You must have a unique constraint on the column representing the path name<ul><li>example: if you have two nodes with a name set to be <code>"backup"</code>, then you
cannot have a path based on the name, like <code>/system/backup</code> because it
would map to two different nodes.</li><li>Option 1: store the full path<ul><li>example: <code>path</code> column with a unique constraint containing the full
path from the root to the node</li><li>cons: need to update the <code>path</code> column on every move operation;</li></ul></li><li>Option 2: store the path component<ul><li>example: <code>name</code> column with a unique constraint together with the
parent_id</li></ul></li></ul></li></ul></li><li>Materialized paths<ul><li>best use cases: tree rarely changes and you need to do traversal queries;
the source of truth for the tree is external, and you are only reading
and replicating.</li><li>avoid: when you have a lot of writes/levels/nodes in the tree; when the
nodes chage position frequently.</li><li>pros: simple query;</li><li>cons: hard to maintain consistency, you need to update the ltree in the
whole tree everytime you move/rename a node in a transaction; write
performance</li></ul></li></ol></article></section></div><footer class=footer><section class=container>©
2025
Lucas Cezimbra
·
<a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script src=/js/htmx.min.c4fce4dc5cc9c8c3c9bf1aa788d54bb2cb25cd27114eb06551494ff61c30d6fb.js integrity="sha256-xPzk3FzJyMPJvxqniNVLssslzScRTrBlUUlP9hww1vs="></script><script src=/jquery-3.6.1.min.min.4833b7f001f63606fe402ea689716ace9d2a681e77e9396cda239bef25214def.js integrity="sha256-SDO38AH2Ngb+QC6miXFqzp0qaB536Tls2iOb7yUhTe8="></script><script src=/jquery.dataTables.min.min.81d3bc71314508a0b97e678aad65ff0b3312dcac9a1a7332273aba32a4802ae4.js integrity="sha256-gdO8cTFFCKC5fmeKrWX/CzMS3KyaGnMyJzq6MqSAKuQ="></script><script src=/vis-timeline-graph2d.min.min.99a125b8efb22795d0bc239c1e3183f23c76fc418a2d2492944b58e3756bf5af.js integrity="sha256-maEluO+yJ5XQvCOcHjGD8jx2/EGKLSSSlEtY43Vr9a8="></script><script data-goatcounter=https://cezimbra.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>